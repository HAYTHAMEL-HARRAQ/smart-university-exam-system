import { Request, Response, NextFunction } from 'express';
import * as oracledb from 'oracledb';

// Oracle database configuration
const oracleConfig: oracledb.PoolOptions = {
  user: process.env.ORACLE_USER || 'exam_system',
  password: process.env.ORACLE_PASSWORD || 'oracle_password',
  connectString: process.env.ORACLE_CONNECTION_STRING || 'localhost:1521/XEPDB1',
  poolMin: 2,
  poolMax: 10,
  poolIncrement: 1,
};

// Initialize Oracle connection pool
export async function initializeOraclePool() {
  try {
    await oracledb.createPool(oracleConfig);
    console.log('✅ Oracle connection pool initialized');
  } catch (err) {
    console.error('❌ Oracle pool initialization error:', err);
  }
}

// Get a connection from the pool
export async function getOracleConnection() {
  try {
    return await oracledb.getConnection();
  } catch (err) {
    console.error('❌ Oracle connection error:', err);
    throw err;
  }
}

// Test Oracle connection
export async function testOracleConnection() {
  let connection;
  try {
    connection = await getOracleConnection();
    const result = await connection.execute('SELECT \'Oracle Connected!\' AS status FROM DUAL');
    console.log('✅ Oracle connection test successful:', result.rows);
    return true;
  } catch (err) {
    console.error('❌ Oracle connection test failed:', err);
    return false;
  } finally {
    if (connection) {
      try {
        await connection.close();
      } catch (err) {
        console.error('Error closing Oracle connection:', err);
      }
    }
  }
}

// Create exam system tables in Oracle
export async function createOracleTables() {
  let connection;
  try {
    connection = await getOracleConnection();
    
    // Create USERS table
    await connection.execute(`
      CREATE TABLE USERS (
        ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        NAME VARCHAR2(255) NOT NULL,
        EMAIL VARCHAR2(255) UNIQUE NOT NULL,
        PASSWORD_HASH VARCHAR2(255) NOT NULL,
        ROLE VARCHAR2(50) NOT NULL,
        CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Create EXAMS table
    await connection.execute(`
      CREATE TABLE EXAMS (
        ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        TITLE VARCHAR2(255) NOT NULL,
        COURSE_CODE VARCHAR2(50),
        DESCRIPTION CLOB,
        DURATION NUMBER,
        TOTAL_QUESTIONS NUMBER,
        MAX_SCORE NUMBER DEFAULT 100,
        STATUS VARCHAR2(50) DEFAULT 'draft',
        CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Create EXAMSESSIONS table
    await connection.execute(`
      CREATE TABLE EXAMSESSIONS (
        ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        EXAM_ID NUMBER NOT NULL,
        STUDENT_ID NUMBER NOT NULL,
        STARTED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        ENDED_AT TIMESTAMP,
        SCORE NUMBER,
        STATUS VARCHAR2(50) DEFAULT 'in_progress',
        BIOMETRIC_VERIFIED NUMBER(1) DEFAULT 0,
        SUSPICIOUS_ACTIVITY_COUNT NUMBER DEFAULT 0,
        IP_ADDRESS VARCHAR2(45),
        FOREIGN KEY (EXAM_ID) REFERENCES EXAMS(ID),
        FOREIGN KEY (STUDENT_ID) REFERENCES USERS(ID)
      )
    `);
    
    // Create ALERTS table
    await connection.execute(`
      CREATE TABLE ALERTS (
        ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        SESSION_ID NUMBER NOT NULL,
        ALERT_TYPE VARCHAR2(100),
        SEVERITY VARCHAR2(20) DEFAULT 'medium',
        DESCRIPTION CLOB,
        CONFIDENCE_SCORE NUMBER,
        ACKNOWLEDGED NUMBER(1) DEFAULT 0,
        CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (SESSION_ID) REFERENCES EXAMSESSIONS(ID)
      )
    `);
    
    // Create INCIDENTS table
    await connection.execute(`
      CREATE TABLE INCIDENTS (
        ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        SESSION_ID NUMBER NOT NULL,
        INCIDENT_TYPE VARCHAR2(100),
        SEVERITY VARCHAR2(20) DEFAULT 'medium',
        DESCRIPTION CLOB,
        RESOLVED NUMBER(1) DEFAULT 0,
        NOTES CLOB,
        CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (SESSION_ID) REFERENCES EXAMSESSIONS(ID)
      )
    `);
    
    console.log('✅ Oracle tables created successfully');
  } catch (err: any) {
    // If tables already exist, that's fine
    if (err.errorNum !== 955) { // ORA-00955: name is already used by an existing object
      console.error('❌ Oracle table creation error:', err);
      throw err;
    } else {
      console.log('ℹ️ Oracle tables already exist');
    }
  } finally {
    if (connection) {
      try {
        await connection.close();
      } catch (err) {
        console.error('Error closing Oracle connection:', err);
      }
    }
  }
}

// Migrate data from MySQL to Oracle
export async function migrateDataToOracle() {
  let mysqlConn, oracleConn;
  try {
    // Get connections
    mysqlConn = await import('./db').then(db => db.default);
    oracleConn = await getOracleConnection();
    
    // Truncate Oracle tables first
    await oracleConn.execute('TRUNCATE TABLE ALERTS');
    await oracleConn.execute('TRUNCATE TABLE EXAMSESSIONS');
    await oracleConn.execute('TRUNCATE TABLE EXAMS');
    await oracleConn.execute('TRUNCATE TABLE INCIDENTS');
    await oracleConn.execute('TRUNCATE TABLE USERS');
    
    // Migrate users
    const mysqlUsers = await mysqlConn.execute('SELECT * FROM users');
    for (const user of mysqlUsers[0]) {
      await oracleConn.execute(`
        INSERT INTO USERS (NAME, EMAIL, PASSWORD_HASH, ROLE, CREATED_AT) 
        VALUES (:name, :email, :password_hash, :role, :created_at)
      `, {
        name: user.name,
        email: user.email,
        password_hash: user.passwordHash,
        role: user.role,
        created_at: user.createdAt
      });
    }
    
    // Migrate exams
    const mysqlExams = await mysqlConn.execute('SELECT * FROM exams');
    for (const exam of mysqlExams[0]) {
      await oracleConn.execute(`
        INSERT INTO EXAMS (TITLE, COURSE_CODE, DESCRIPTION, DURATION, TOTAL_QUESTIONS, MAX_SCORE, STATUS, CREATED_AT)
        VALUES (:title, :course_code, :description, :duration, :total_questions, :max_score, :status, :created_at)
      `, {
        title: exam.title,
        course_code: exam.courseCode,
        description: exam.description,
        duration: exam.duration,
        total_questions: exam.totalQuestions,
        max_score: exam.maxScore,
        status: exam.status,
        created_at: exam.createdAt
      });
    }
    
    // Migrate exam sessions
    const mysqlSessions = await mysqlConn.execute('SELECT * FROM examSessions');
    for (const session of mysqlSessions[0]) {
      await oracleConn.execute(`
        INSERT INTO EXAMSESSIONS (EXAM_ID, STUDENT_ID, STARTED_AT, ENDED_AT, SCORE, STATUS, BIOMETRIC_VERIFIED, SUSPICIOUS_ACTIVITY_COUNT, IP_ADDRESS)
        VALUES (:exam_id, :student_id, :started_at, :ended_at, :score, :status, :biometric_verified, :suspicious_activity_count, :ip_address)
      `, {
        exam_id: session.examId,
        student_id: session.studentId,
        started_at: session.startedAt,
        ended_at: session.endedAt,
        score: session.score,
        status: session.status,
        biometric_verified: session.biometricVerified ? 1 : 0,
        suspicious_activity_count: session.suspiciousActivityCount,
        ip_address: session.ipAddress
      });
    }
    
    // Migrate alerts
    const mysqlAlerts = await mysqlConn.execute('SELECT * FROM alerts');
    for (const alert of mysqlAlerts[0]) {
      await oracleConn.execute(`
        INSERT INTO ALERTS (SESSION_ID, ALERT_TYPE, SEVERITY, DESCRIPTION, CONFIDENCE_SCORE, ACKNOWLEDGED, CREATED_AT)
        VALUES (:session_id, :alert_type, :severity, :description, :confidence_score, :acknowledged, :created_at)
      `, {
        session_id: alert.sessionId,
        alert_type: alert.alertType,
        severity: alert.severity,
        description: alert.description,
        confidence_score: alert.confidenceScore,
        acknowledged: alert.acknowledged ? 1 : 0,
        created_at: alert.createdAt
      });
    }
    
    // Migrate incidents
    const mysqlIncidents = await mysqlConn.execute('SELECT * FROM incidents');
    for (const incident of mysqlIncidents[0]) {
      await oracleConn.execute(`
        INSERT INTO INCIDENTS (SESSION_ID, INCIDENT_TYPE, SEVERITY, DESCRIPTION, RESOLVED, NOTES, CREATED_AT)
        VALUES (:session_id, :incident_type, :severity, :description, :resolved, :notes, :created_at)
      `, {
        session_id: incident.sessionId,
        incident_type: incident.incidentType,
        severity: incident.severity,
        description: incident.description,
        resolved: incident.resolved ? 1 : 0,
        notes: incident.notes,
        created_at: incident.createdAt
      });
    }
    
    console.log('✅ Data migrated from MySQL to Oracle successfully');
  } catch (err) {
    console.error('❌ Data migration error:', err);
    throw err;
  } finally {
    if (mysqlConn) {
      // Close MySQL connection if needed
    }
    if (oracleConn) {
      try {
        await oracleConn.close();
      } catch (err) {
        console.error('Error closing Oracle connection:', err);
      }
    }
  }
}

// Middleware to check Oracle availability
export async function oracleHealthCheck(req: Request, res: Response, next: NextFunction) {
  try {
    const isConnected = await testOracleConnection();
    if (isConnected) {
      next();
    } else {
      res.status(503).json({ error: 'Oracle database not available' });
    }
  } catch (err) {
    res.status(503).json({ error: 'Oracle database connection failed' });
  }
}

// Export the oracledb module for direct use
export { oracledb };